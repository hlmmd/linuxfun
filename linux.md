

## 创建守护进程

### 进程组

* 每个进程属于一个进程组
* 每个进程主都有一个进程组号，该号等于该进程组组长的PID号
* 一个进程只能为它自己或子进程设置进程组ID号

### 会话期

会话期(session)是一个或多个进程组的集合。

setsid()函数可以建立一个对话期

如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。

1. 此进程变成该对话期的首进程
2. 此进程变成一个新进程组的组长进程。
3. 此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。
4. 先调用fork()然后exit()退出父进程，子进程一定不会是进程组组长，setsid函数一定能成功。

### 创建守护进程所需步骤：

1. 在父进程中执行fork并exit推出；
2. 在子进程中调用setsid函数创建新的会话；
3. 在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录；
4. 在子进程中调用umask函数，设置进程的umask为0；
5. 在子进程中关闭任何不需要的文件描述符

### 守护进程要fork两次的原因：

第一次fork：这里第一次fork的作用就是让shell认为这条命令已经终止，不用挂在终端输入上;再一个是为了后面的setsid服务，因为调用setsid函数的进程不能是进程组组长，如果不fork子进程，那么此时的父进程是进程组组长，无法调用setsid。所以到这里子进程便成为了一个新会话组的组长。

第二次fork：第2次fork不是必须的。也看到很多开源服务没有fork第二次。fork第二次主要目的是。防止进程再次打开一个控制终端。因为打开一个控制终端的前台条件是该进程必须是会话组长。再fork一次，子进程ID != sid（sid是进程父进程的sid）。所以也无法打开新的控制终端。

