# Linux多线程服务端编程 使用muduo c++网络库

## 1 线程安全的对象生命周期管理

用同步原语(synchronization primitives)保护内部状态即可。但是对象的生与死不能由对象自身拥有的 mutex(互斥器)来保护。

* 在即将析构一个对象时,从何而知此刻是否有别的线程正在执行该对象的成员
函数?
* 如何保证在执行成员函数期间,对象不会在另一个线程被析构?
* 在调用某个对象的成员函数之前,如何得知这个对象还活着?它的析构函数会
不会碰巧执行到一半?

### 线程安全的定义

* 多个线程同时访问，表现正确。
* 不受进程调度影响
* 调用段代码无需额外操作

### MutexLock 与 MutexLockGuard

MutexLock 封装临界区(critical section)

MutexLockGuard 封装临界区的进入和退出,即加锁和解锁

### 线程安全的counter类

## 构造函数的线程安全

* 不要在构造函数中注册任何回调;
* 也不要在构造函数中把 this 传给跨线程的对象;
* 即便在构造函数的最后一行也不行（考虑子类调用基类构造函数后再调用自身构造函数）。

## 析构函数的线程安全

野指针：未初始化的指针

空悬指针：指向已经销毁的对象